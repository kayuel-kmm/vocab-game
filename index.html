<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ë‹¨ì–´ ê²Œì„ v5.4 (íˆ´ë°” ê°€ë¦¼ ìµœì†Œí™” + 2ë²ˆ ë°œìŒ)</title>
  <style>
    :root { --gap: 12px; }
    html, body { height: 100%; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; margin: 0; background:#f6f7fb; }

    header { padding: 14px 12px; background: white; border-bottom: 1px solid #e7e7ee; position: sticky; top:0; z-index: 10; }
    main { max-width: 980px; margin: 0 auto; padding: 12px; display: grid; gap: 12px; }

    .card { background: white; border:1px solid #e7e7ee; border-radius: 16px; padding: 14px; box-shadow: 0 4px 14px rgba(10,10,20,.04); }
    .row { display:flex; gap: var(--gap); flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1; min-width: 140px; }

    input, select, button, textarea { font: inherit; padding: 12px 12px; border-radius: 12px; border: 1px solid #d9d9e6; background: white; }
    textarea { width:100%; min-height: 90px; }

    button { cursor:pointer; border:1px solid #cfcfe2; background:#111827; color:white; }
    button.secondary { background:white; color:#111827; }
    button.ghost { background: #eef2ff; color:#111827; border-color:#d6dcff; }
    button.danger { background:#b91c1c; }
    button:disabled { opacity:.55; cursor:not-allowed; }

    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; background:#eef2ff; border:1px solid #d6dcff; border-radius:999px; font-size: 13px; }
    .big { font-size: 30px; font-weight: 900; letter-spacing: .2px; }
    .muted { color:#6b7280; font-size: 13px; }

    .progress { height:10px; background:#eef2ff; border:1px solid #d6dcff; border-radius:999px; overflow:hidden; }
    .bar { height:100%; background:#4f46e5; width:0%; }

    .options { display:grid; gap: 10px; }
    .options button { text-align:left; background:white; color:#111827; font-size: 18px; padding: 14px 12px; }
    .options button.correct { border-color:#16a34a; background:#ecfdf3; }
    .options button.wrong { border-color:#dc2626; background:#fff1f2; }

    .list { width:100%; border-collapse: collapse; }
    .list th, .list td { border-bottom: 1px solid #eee; padding: 8px; text-align:left; font-size: 14px; vertical-align: middle; }
    .right { text-align:right; }
    .chk { width:18px; height:18px; vertical-align: middle; }

    /* ===== ê²Œì„í™”ë©´ë§Œ(í’€ìŠ¤í¬ë¦°) ===== */
    body.gameOnly { overflow: hidden; }
    body.gameOnly header, body.gameOnly #adminCard, body.gameOnly #listCard { display:none !important; }

    body.gameOnly main { height: 100vh; padding: 8px; gap: 8px; }
    body.gameOnly #gameCard { display:block !important; height: calc(100vh - 16px); overflow: hidden; padding: 8px; border-radius: 14px; }

    /* âœ… í•˜ë‹¨ ë‚´ë¹„ê²Œì´ì…˜ ë°”(ì•ˆì „ì˜ì—­) ê°€ë¦¼ ë°©ì§€ */
    body.gameOnly #gameCard { padding-bottom: calc(10px + env(safe-area-inset-bottom)); }
    body.gameOnly #gameBottom { padding-bottom: calc(10px + env(safe-area-inset-bottom)); }

    body.gameOnly #gameLayout { height: 100%; display: flex; flex-direction: column; gap: 8px; }

    body.gameOnly .big { font-size: 24px; line-height: 1.08; }
    body.gameOnly .muted { font-size: 12px; }
    body.gameOnly .pill { font-size: 11px; padding: 4px 7px; gap:6px; }
    body.gameOnly button, body.gameOnly input, body.gameOnly select { padding: 8px 9px; border-radius: 10px; }

    body.gameOnly #statusRow { display:flex; gap: 6px; flex-wrap: nowrap; align-items: center; overflow: hidden; }
    body.gameOnly #statusRow .pill { white-space: nowrap; flex: 0 0 auto; }

    body.gameOnly #gameTop { flex: 0 0 auto; }
    body.gameOnly #hint { display:none; }
    body.gameOnly #ttsNote { display:none; }

    body.gameOnly #gameMiddle { flex: 1; overflow: auto; -webkit-overflow-scrolling: touch; padding-bottom: 2px; }
    body.gameOnly .options { grid-template-columns: 1fr 1fr; gap: 7px; }
    body.gameOnly .options button { font-size: 16px; padding: 11px 10px; }

    .chunkCard { border: 1px solid #e7e7ee; border-radius: 14px; padding: 10px; background: #fff; }
    body.gameOnly .chunkCard { padding: 9px; border-radius: 12px; }

    body.gameOnly #gameBottom { flex: 0 0 auto; }
    body.gameOnly #gameBottom .row { gap: 6px; }

    body.gameOnly .btnSmall { padding: 6px 8px !important; font-size: 12px !important; border-radius: 10px !important; }
    body.gameOnly .btnBig { padding: 10px 12px !important; font-size: 15px !important; font-weight: 800; }

    /* âœ… ë‹¨ì–´ ì˜† ìŠ¤í”¼ì»¤ ë²„íŠ¼ */
    .promptRow { display:flex; align-items:center; gap: 10px; }
    .promptRow .big { flex: 1; }
    .promptSpeak { flex: 0 0 auto; padding: 10px 12px; border-radius: 12px; }
    body.gameOnly .promptSpeak { padding: 8px 10px; border-radius: 10px; }

    /* âœ… 'ë‹¤ìŒ' ë²„íŠ¼ ì¤„ì„ ì•„ë˜íˆ´ë°”ì—ì„œ ë” ë©€ë¦¬(ìœ„ë¡œ) */
    body.gameOnly #nextRow { margin-top: 6px; }

    /* ê²°ê³¼ í™”ë©´ */
    #resultPanel { display:none; }
    #resultPanel .big { font-size: 28px; }
    body.gameOnly #resultPanel .big { font-size: 22px; }
  </style>
</head>

<body>
<header>
  <div class="row" style="max-width:980px;margin:0 auto;">
    <div style="flex:2;min-width:220px;">
      <div style="font-weight:900;">ë‹¨ì–´ ê²Œì„ v5.4</div>
      <div class="muted">íˆ´ë°” ê°€ë¦¼ ìµœì†Œí™” + 2ë²ˆ ë°œìŒ + ê²°ê³¼/ì˜¤ë‹µì¬ë„ì „ + 20ë¬¸í•­ + 3ì¡°ê°</div>
    </div>
    <div class="row" style="justify-content:flex-end; flex:1;">
      <span class="pill" id="countPill">ë‹¨ì–´ 0ê°œ</span>
      <select id="mode">
        <option value="meaning">1ë‹¨ê³„: ëœ»</option>
        <option value="pron">2ë‹¨ê³„: ë°œìŒ(í•œê¸€)</option>
        <option value="spelling">3ë‹¨ê³„: ìŠ¤í ë§(3ì¡°ê°)</option>
      </select>
      <button class="ghost" id="startBtn">ì‹œì‘</button>
    </div>
  </div>
</header>

<main>
  <section class="card" id="adminCard">
    <div class="row">
      <div style="flex:2;min-width:240px;">
        <div style="font-weight:900;">ë‹¨ì–´ ê´€ë¦¬</div>
        <div class="muted">ëŒ€ëŸ‰ ì…ë ¥ìœ¼ë¡œ ì¶”ê°€ í›„, â€œì´ë²ˆ ì£¼â€ ì²´í¬ë¡œ ì£¼ê°„ ì¶œì œ ê´€ë¦¬</div>
      </div>
      <div class="right" style="flex:1;">
        <button class="secondary" id="exportBtn">ë‚´ë³´ë‚´ê¸°(JSON)</button>
        <button class="secondary" id="importBtn">ê°€ì ¸ì˜¤ê¸°(JSON)</button>
        <button class="danger" id="resetBtn">ì „ì²´ ì‚­ì œ</button>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <input id="w_en" placeholder="ì˜ë‹¨ì–´ (ì˜ˆ: excellent)" autocomplete="off" />
      <input id="w_ko" placeholder="ëœ» (ì˜ˆ: í›Œë¥­í•œ)" autocomplete="off" />
      <input id="w_pron" placeholder="ë°œìŒ(í•œê¸€) (ì˜ˆ: ì—‘ì„¤ëŸ°íŠ¸)" autocomplete="off" />
      <label class="pill" style="flex:0;min-width:auto;">
        <input type="checkbox" id="w_week" class="chk" />
        ì´ë²ˆ ì£¼
      </label>
      <button id="addBtn">ì¶”ê°€</button>
    </div>

    <details style="margin-top:12px;">
      <summary class="muted">ëŒ€ëŸ‰ ì…ë ¥(ê°„ë‹¨): ì˜ì–´ë§Œ / ë˜ëŠ” ì˜ì–´|ëœ»|ë°œìŒ|week</summary>
      <textarea id="bulk"></textarea>
      <div class="row" style="margin-top:8px;">
        <button class="secondary" id="bulkAddBtn">ëŒ€ëŸ‰ ì¶”ê°€</button>
        <span class="muted">ì˜ì–´ë§Œ ë„£ìœ¼ë©´ ëœ»/ë°œìŒì€ ë¹ˆì¹¸ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤.</span>
      </div>
    </details>

    <div class="row" style="margin-top:12px;">
      <button class="secondary" id="clearWeeklyBtn">ì´ë²ˆ ì£¼ ì „ì²´ í•´ì œ</button>
      <button class="secondary" id="markAllWeeklyBtn">ì „ì²´ë¥¼ ì´ë²ˆ ì£¼ë¡œ</button>
      <span class="muted">â€» ìƒˆ ì£¼ ì‹œì‘ ì‹œ â€œì´ë²ˆ ì£¼ ì „ì²´ í•´ì œâ€ â†’ ìƒˆ 10~20ê°œë§Œ ì²´í¬</span>
    </div>
  </section>

  <section class="card" id="gameCard" style="display:none;">
    <div id="gameLayout">

      <div id="gameTop">
        <div class="muted" id="stageLabel">ë‹¨ê³„</div>

        <div class="promptRow">
          <div class="big" id="prompt">-</div>
          <button class="secondary promptSpeak" id="promptSpeakBtn" title="ë°œìŒ ë“£ê¸°">ğŸ”Š</button>
        </div>

        <div class="muted" id="hint"> </div>

        <div class="progress" style="margin-top:6px;"><div class="bar" id="bar"></div></div>
        <div id="statusRow" style="margin-top:6px;">
          <span class="pill" id="scorePill">ì ìˆ˜ 0</span>
          <span class="pill" id="idxPill">0 / 0</span>
          <span class="pill" id="streakPill">ì—°ì† 0</span>
          <span class="pill" id="starsPill">â­ 0</span>
          <span class="pill" id="stickersPill">ğŸ… 0</span>
        </div>
      </div>

      <div id="gameMiddle">
        <div id="quizPanel">
          <div class="options" id="options"></div>

          <div id="chunkArea" style="display:none; margin-top:10px;">
            <div class="muted">ì¡°ê°ì„ ìˆœì„œëŒ€ë¡œ ê³¨ë¼ ë‹¨ì–´ë¥¼ ì™„ì„±í•˜ì„¸ìš”. (ìµœëŒ€ 3ì¡°ê°)</div>
            <div id="chunkSlots" style="display:grid; gap:8px; margin-top:8px;"></div>
            <div class="row" style="margin-top:10px;">
              <span class="pill" id="builtWordPill">ì™„ì„±: </span>
              <button class="secondary btnSmall" id="resetChunksBtn">ì²˜ìŒë¶€í„°</button>
              <button class="ghost btnSmall" id="checkChunksBtn">ì •ë‹µ í™•ì¸</button>
            </div>
            <div class="muted" id="chunkFeedback" style="margin-top:6px;"></div>
          </div>
        </div>

        <div id="resultPanel">
          <div class="big" id="resultTitle">ë!</div>
          <div class="muted" id="resultSub" style="margin-top:6px;"></div>

          <div class="row" style="margin-top:10px;">
            <span class="pill" id="resultScorePill">ì ìˆ˜</span>
            <span class="pill" id="resultWrongPill">ì˜¤ë‹µ</span>
            <span class="pill" id="resultStarsPill">â­</span>
            <span class="pill" id="resultStickersPill">ğŸ…</span>
          </div>

          <div class="row" style="margin-top:12px;">
            <button class="ghost btnBig" id="retryWrongBtn">ì˜¤ë‹µ ë‹¤ì‹œ í’€ê¸°</button>
            <button class="secondary btnBig" id="retryAllBtn">í•œ ë²ˆ ë”</button>
          </div>
          <div class="row" style="margin-top:10px;">
            <button class="secondary btnSmall" id="backToManageBtn">ê´€ë¦¬ í™”ë©´</button>
          </div>
        </div>
      </div>

      <!-- âœ… 'ë‹¤ìŒ' ì¤„ì„ ìœ„ë¡œ ì˜¬ë¦¬ê¸° ìœ„í•´: nextRowë¥¼ gameBottom ìœ„ìª½ì— ë°°ì¹˜ -->
      <div id="nextRow" class="row">
        <button class="secondary btnBig" id="skipBtn">ê±´ë„ˆë›°ê¸°</button>
        <button class="ghost btnBig" id="nextBtn" style="display:none;">ë‹¤ìŒ</button>
        <span class="muted" id="rewardHint" style="flex:1; min-width: 160px;"></span>
      </div>

      <div id="gameBottom">
        <div class="row">
          <select class="btnSmall" id="scope">
            <option value="weekly">ì´ë²ˆ ì£¼</option>
            <option value="all">ëˆ„ì </option>
          </select>
          <button class="secondary btnSmall" id="reviewBtn">ë³µìŠµ</button>
          <button class="secondary btnSmall" id="speakBtn">ğŸ”Š</button>
          <label class="pill btnSmall" style="gap:8px; flex:0; min-width:auto;">
            <input type="checkbox" id="autoSpeak" class="chk" />
            ìë™
          </label>
          <button class="secondary btnSmall" id="toggleGameOnly">ğŸ“±</button>
          <button class="ghost btnSmall" id="rewardBtn">ë³´ìƒ</button>
        </div>

        <div class="muted" id="ttsNote" style="margin-top:4px;"></div>
        <div class="muted" id="feedback" style="margin-top:4px;"></div>
      </div>
    </div>
  </section>

  <section class="card" id="listCard">
    <div class="row">
      <div style="flex:2;">
        <div style="font-weight:900;">ë‹¨ì–´ ëª©ë¡</div>
        <div class="muted">ìˆ˜ì •/ì‚­ì œ + â€œì´ë²ˆ ì£¼â€ ì²´í¬</div>
      </div>
    </div>
    <div style="overflow:auto; margin-top:10px;">
      <table class="list">
        <thead>
          <tr><th>ì´ë²ˆ ì£¼</th><th>ì˜ë‹¨ì–´</th><th>ëœ»</th><th>ë°œìŒ(í•œê¸€)</th><th class="right">ê´€ë¦¬</th></tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </section>
</main>

<script>
(() => {
  const LS_WORDS = "kid_vocab_v54_words";
  const LS_TTS   = "kid_vocab_v54_tts";
  const LS_META  = "kid_vocab_v54_meta";

  const DEFAULT_WORDS = [
    {"en":"fun","ko":"ì¬ë¯¸ìˆëŠ”","pron":"í€","weekly":true},
    {"en":"school","ko":"í•™êµ","pron":"ìŠ¤ì¿¨","weekly":true},
    {"en":"excellent","ko":"ì•„ì£¼ í›Œë¥­í•œ","pron":"ì—‘ì„¤ëŸ°íŠ¸","weekly":true},
    {"en":"book","ko":"ì±…","pron":"ë¶","weekly":true}
  ];

  let words = loadWords();
  let meta = loadMeta();

  let quiz = null;
  let chunkState = null;
  let currentWord = null;

  // elements
  const countPill = document.getElementById("countPill");
  const modeSel = document.getElementById("mode");
  const startBtn = document.getElementById("startBtn");

  const w_en = document.getElementById("w_en");
  const w_ko = document.getElementById("w_ko");
  const w_pron = document.getElementById("w_pron");
  const w_week = document.getElementById("w_week");
  const addBtn = document.getElementById("addBtn");

  const bulk = document.getElementById("bulk");
  const bulkAddBtn = document.getElementById("bulkAddBtn");

  const exportBtn = document.getElementById("exportBtn");
  const importBtn = document.getElementById("importBtn");
  const resetBtn = document.getElementById("resetBtn");
  const clearWeeklyBtn = document.getElementById("clearWeeklyBtn");
  const markAllWeeklyBtn = document.getElementById("markAllWeeklyBtn");

  const gameCard = document.getElementById("gameCard");
  const stageLabel = document.getElementById("stageLabel");
  const promptEl = document.getElementById("prompt");
  const hintEl = document.getElementById("hint");
  const optionsEl = document.getElementById("options");

  const promptSpeakBtn = document.getElementById("promptSpeakBtn");

  const quizPanel = document.getElementById("quizPanel");
  const resultPanel = document.getElementById("resultPanel");

  const resultTitle = document.getElementById("resultTitle");
  const resultSub = document.getElementById("resultSub");
  const resultScorePill = document.getElementById("resultScorePill");
  const resultWrongPill = document.getElementById("resultWrongPill");
  const resultStarsPill = document.getElementById("resultStarsPill");
  const resultStickersPill = document.getElementById("resultStickersPill");
  const retryWrongBtn = document.getElementById("retryWrongBtn");
  const retryAllBtn = document.getElementById("retryAllBtn");
  const backToManageBtn = document.getElementById("backToManageBtn");

  const chunkArea = document.getElementById("chunkArea");
  const chunkSlots = document.getElementById("chunkSlots");
  const builtWordPill = document.getElementById("builtWordPill");
  const resetChunksBtn = document.getElementById("resetChunksBtn");
  const checkChunksBtn = document.getElementById("checkChunksBtn");
  const chunkFeedback = document.getElementById("chunkFeedback");

  const scorePill = document.getElementById("scorePill");
  const idxPill = document.getElementById("idxPill");
  const streakPill = document.getElementById("streakPill");
  const bar = document.getElementById("bar");

  const scopeSel = document.getElementById("scope");
  const reviewBtn = document.getElementById("reviewBtn");

  const speakBtn = document.getElementById("speakBtn");
  const autoSpeak = document.getElementById("autoSpeak");
  const ttsNote = document.getElementById("ttsNote");
  const toggleGameOnly = document.getElementById("toggleGameOnly");

  const starsPill = document.getElementById("starsPill");
  const stickersPill = document.getElementById("stickersPill");
  const rewardBtn = document.getElementById("rewardBtn");
  const rewardHint = document.getElementById("rewardHint");

  const skipBtn = document.getElementById("skipBtn");
  const nextBtn = document.getElementById("nextBtn");
  const feedbackEl = document.getElementById("feedback");

  const tbody = document.getElementById("tbody");

  // ---------- migration ----------
  function migrateWordsIfNeeded() {
    const candidates = [
      LS_WORDS,
      "kid_vocab_v53_words",
      "kid_vocab_v52_words",
      "kid_vocab_v4_words",
      "kid_vocab_v3_words",
      "kid_vocab_v2",
      "kid_vocab_v5_words",
    ];
    if (localStorage.getItem(LS_WORDS)) return;
    for (const key of candidates) {
      const raw = localStorage.getItem(key);
      if (raw && raw.trim().startsWith("[")) { localStorage.setItem(LS_WORDS, raw); return; }
    }
  }

  function loadWords() {
    migrateWordsIfNeeded();
    try {
      const raw = localStorage.getItem(LS_WORDS);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      return arr.filter(x => x && typeof x.en === "string")
        .map(x => ({
          id: x.id || crypto.randomUUID(),
          en: (x.en||"").trim(),
          ko: (x.ko||"").trim(),
          pron: (x.pron||"").trim(),
          weekly: !!x.weekly,
          spell: x.spell || null
        }))
        .filter(x => x.en.length > 0);
    } catch { return []; }
  }

  function saveWords() {
    localStorage.setItem(LS_WORDS, JSON.stringify(words));
    renderCount(); renderList();
  }

  function loadMeta() {
    try {
      const raw = localStorage.getItem(LS_META);
      if (!raw) return { stars: 0, stickers: 0, streak: 0, wrongIds: [] };
      const x = JSON.parse(raw);
      return {
        stars: Number.isFinite(x.stars) ? x.stars : 0,
        stickers: Number.isFinite(x.stickers) ? x.stickers : 0,
        streak: Number.isFinite(x.streak) ? x.streak : 0,
        wrongIds: Array.isArray(x.wrongIds) ? x.wrongIds : []
      };
    } catch { return { stars: 0, stickers: 0, streak: 0, wrongIds: [] }; }
  }

  function saveMeta() {
    localStorage.setItem(LS_META, JSON.stringify(meta));
    renderReward();
  }

  function loadTts() {
    try {
      const raw = localStorage.getItem(LS_TTS);
      if (!raw) return { autoSpeak: true };
      const x = JSON.parse(raw);
      return { autoSpeak: !!x.autoSpeak };
    } catch { return { autoSpeak: true }; }
  }

  function saveTts() {
    localStorage.setItem(LS_TTS, JSON.stringify({ autoSpeak: autoSpeak.checked }));
  }

  // ---------- UI ----------
  function renderCount() { countPill.textContent = `ë‹¨ì–´ ${words.length}ê°œ`; }
  function escapeHtml(s) { return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;"); }

  function renderList() {
    tbody.innerHTML = "";
    for (const w of words) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input type="checkbox" class="chk" data-week="${w.id}" ${w.weekly ? "checked":""} /></td>
        <td><input data-k="en" data-id="${w.id}" value="${escapeHtml(w.en)}" /></td>
        <td><input data-k="ko" data-id="${w.id}" value="${escapeHtml(w.ko)}" /></td>
        <td><input data-k="pron" data-id="${w.id}" value="${escapeHtml(w.pron)}" /></td>
        <td class="right"><button class="danger" data-del="${w.id}">ì‚­ì œ</button></td>`;
      tbody.appendChild(tr);
    }
    tbody.querySelectorAll("input[data-week]").forEach(chk => chk.addEventListener("change", (e) => {
      const id = e.target.getAttribute("data-week");
      const idx = words.findIndex(x => x.id === id);
      if (idx >= 0) { words[idx].weekly = e.target.checked; saveWords(); }
    }));
    tbody.querySelectorAll("input[data-id]").forEach(inp => inp.addEventListener("change", (e) => {
      const id = e.target.getAttribute("data-id");
      const k = e.target.getAttribute("data-k");
      const val = e.target.value.trim();
      const idx = words.findIndex(x => x.id === id);
      if (idx >= 0) { words[idx][k] = val; saveWords(); }
    }));
    tbody.querySelectorAll("button[data-del]").forEach(btn => btn.addEventListener("click", () => {
      const id = btn.getAttribute("data-del");
      words = words.filter(x => x.id !== id);
      meta.wrongIds = meta.wrongIds.filter(x => x !== id);
      saveWords(); saveMeta();
    }));
  }

  function addWord(en, ko, pron, weekly) {
    en = (en || "").trim(); ko = (ko || "").trim(); pron = (pron || "").trim();
    if (!en) return;
    const exists = words.find(w => w.en.toLowerCase() === en.toLowerCase());
    if (exists) {
      exists.ko = ko || exists.ko;
      exists.pron = pron || exists.pron;
      if (weekly !== undefined) exists.weekly = !!weekly;
    } else {
      words.unshift({ id: crypto.randomUUID(), en, ko, pron, weekly: !!weekly, spell: null });
    }
    saveWords();
  }

  function seedDefaultWordsIfEmpty() {
    if (Array.isArray(words) && words.length > 0) return;
    for (const x of DEFAULT_WORDS) addWord(x.en, x.ko || "", x.pron || "", x.weekly ?? true);
  }

  function renderReward() {
    starsPill.textContent = `â­ ${meta.stars}`;
    stickersPill.textContent = `ğŸ… ${meta.stickers}`;
    const need = 10;
    const can = Math.floor(meta.stars / need);
    rewardBtn.disabled = can <= 0;
    rewardHint.textContent = can > 0 ? `ë³´ìƒ ${can}ê°œ ê°€ëŠ¥` : `â­${need}ê°œ=ğŸ…1`;
    streakPill.textContent = `ì—°ì† ${meta.streak}`;
  }

  rewardBtn.addEventListener("click", () => {
    const need = 10;
    if (Math.floor(meta.stars / need) <= 0) return;
    meta.stars -= need; meta.stickers += 1;
    saveMeta();
    alert("ë³´ìƒ íšë“! ğŸ… +1");
  });

  // ---------- gameOnly ----------
  function setGameOnly(on) {
    document.body.classList.toggle("gameOnly", !!on);
    toggleGameOnly.textContent = document.body.classList.contains("gameOnly") ? "â†©ï¸" : "ğŸ“±";
  }
  toggleGameOnly.addEventListener("click", () => setGameOnly(!document.body.classList.contains("gameOnly")));

  function autoGameOnlyOnMobile() {
    const isMobile = window.matchMedia && window.matchMedia("(max-width: 760px)").matches;
    if (isMobile) setGameOnly(true);
  }

  backToManageBtn.addEventListener("click", () => {
    setGameOnly(false);
    gameCard.style.display = "none";
  });

  // ---------- TTS (2ë²ˆ ì½ê¸°) ----------
  let bestEnVoice = null;
  function pickEnglishVoice() {
    const voices = speechSynthesis.getVoices();
    bestEnVoice = voices.find(v => /^en(-|_)/i.test(v.lang)) || voices.find(v => /English/i.test(v.name)) || null;
  }
  function speakOnce(text, rate=0.88) {
    if (!("speechSynthesis" in window)) return;
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "en-US";
    if (bestEnVoice) u.voice = bestEnVoice;
    u.rate = rate;
    speechSynthesis.speak(u);
  }
  function speakTwice(text) {
    if (!("speechSynthesis" in window)) return;
    try { speechSynthesis.cancel(); } catch {}
    // 1) ìì—°ìŠ¤ëŸ½ê²Œ
    speakOnce(text, 0.92);
    // 2) ì¡°ê¸ˆ ë” ì²œì²œíˆ
    setTimeout(() => speakOnce(text, 0.82), 650);
  }
  function updateTtsNote() {
    const hasApi = "speechSynthesis" in window && "SpeechSynthesisUtterance" in window;
    if (!hasApi) { ttsNote.textContent = ""; speakBtn.disabled = true; promptSpeakBtn.disabled = true; return; }
    ttsNote.textContent = "";
  }
  if ("speechSynthesis" in window) {
    pickEnglishVoice();
    speechSynthesis.onvoiceschanged = () => pickEnglishVoice();
  }

  function speakCurrentWord() {
    if (!currentWord || !currentWord.en) return;
    speakTwice(currentWord.en);
  }
  promptSpeakBtn.addEventListener("click", speakCurrentWord);
  speakBtn.addEventListener("click", speakCurrentWord);
  autoSpeak.addEventListener("change", saveTts);

  // ---------- pool helpers ----------
  function weeklyWords(){ return words.filter(w=>w.weekly); }
  function currentPool(){ return scopeSel.value==="weekly" ? weeklyWords() : words; }

  // ---------- spelling: 3ì¡°ê° & í›„ë³´ ê³ ì • ----------
  const CONF = {
    "sch": ["sch","sk","ck"],
    "sh": ["sh","s","ch"],
    "ch": ["ch","sh","tch"],
    "ck": ["ck","k","c"],
    "ph": ["ph","f","p"],
    "th": ["th","t","s"],
    "wh": ["wh","w","h"],
    "oo": ["oo","u","ou"],
    "ee": ["ee","i","ea"],
    "ea": ["ea","e","ee"],
    "ai": ["ai","a","ay"],
    "ay": ["ay","ai","a"],
    "oa": ["oa","o","ow"],
    "ow": ["ow","o","oa"],
    "ou": ["ou","u","oo"],
    "ar": ["ar","er","or"],
    "er": ["er","ar","or"],
    "or": ["or","er","ar"],
    "ur": ["ur","er","or"],
    "tion": ["tion","shun","cion"],
    "ing": ["ing","in","ng"]
  };

  function dedupeCase(arr) {
    const out = [];
    for (const x of arr) if (!out.map(o=>String(o).toLowerCase()).includes(String(x).toLowerCase())) out.push(x);
    return out;
  }

  function mutateChunk(chunk) {
    const low = chunk.toLowerCase();
    const rules = [
      [/c/g, "k"], [/k/g, "c"],
      [/ph/g, "f"], [/f/g, "ph"],
      [/sh/g, "ch"], [/ch/g, "sh"],
      [/oo/g, "u"], [/u/g, "oo"],
      [/ee/g, "i"], [/i/g, "ee"],
      [/a/g, "e"], [/e/g, "a"],
      [/o/g, "u"], [/u/g, "o"],
      [/l/g, "r"], [/r/g, "l"]
    ];
    const variants = [];
    for (const [re, rep] of rules) {
      if (re.test(low)) {
        const v = low.replace(re, rep);
        if (v !== low) variants.push(v);
      }
      if (variants.length >= 4) break;
    }
    return dedupeCase([chunk, ...variants]).slice(0, 3);
  }

  function initialChunks(en) {
    const low = en.toLowerCase();
    const keys = Object.keys(CONF).sort((a,b)=>b.length-a.length);
    const chunks = [];
    let i = 0;
    while (i < low.length) {
      let matched = null;
      for (const k of keys) { if (low.startsWith(k, i)) { matched = k; break; } }
      if (matched) {
        const corr = en.slice(i, i+matched.length);
        const options = dedupeCase([corr, ...CONF[matched]]).slice(0,3);
        chunks.push({ correct:corr, options });
        i += matched.length;
      } else {
        const corr = en[i];
        chunks.push({ correct:corr, options: mutateChunk(corr) });
        i += 1;
      }
    }
    return chunks;
  }

  function mergeToMax3(chunks) {
    if (chunks.length <= 3) return chunks;
    let parts = chunks.map(c => ({ correct:c.correct }));
    while (parts.length > 3) {
      let minIdx = 0;
      for (let i=1;i<parts.length;i++) if (parts[i].correct.length < parts[minIdx].correct.length) minIdx = i;
      const leftIdx = minIdx - 1, rightIdx = minIdx + 1;
      if (leftIdx >= 0) { parts[leftIdx].correct += parts[minIdx].correct; parts.splice(minIdx, 1); }
      else if (rightIdx < parts.length) { parts[minIdx].correct += parts[rightIdx].correct; parts.splice(rightIdx, 1); }
      else break;
    }
    return parts.map(p => ({ correct: p.correct, options: mutateChunk(p.correct) }));
  }

  function buildSpellParts(en) { return mergeToMax3(initialChunks(en)); }

  function startChunkPuzzle(word) {
    const spell = (word.spell && Array.isArray(word.spell) && word.spell.length)
      ? mergeToMax3(word.spell)
      : buildSpellParts(word.en);

    const optOrder = spell.map(p => shuffle([...p.options])); // 1íšŒ ê³ ì •
    chunkState = { spell, picks: new Array(spell.length).fill(null), optOrder };

    chunkFeedback.textContent = "";
    renderChunkSlots();
    updateBuiltWord();
  }

  function renderChunkSlots() {
    chunkSlots.innerHTML = "";
    chunkState.spell.forEach((part, idx) => {
      const slot = document.createElement("div");
      slot.className = "chunkCard";
      // âœ… "1ë²ˆì§¸/2ë²ˆì§¸/3ë²ˆì§¸" í‘œì‹œ ì œê±°
      slot.innerHTML = `<div class="row" style="gap:6px;"></div>`;
      const row = slot.querySelector(".row");

      chunkState.optOrder[idx].forEach(opt => {
        const b = document.createElement("button");
        b.className = "secondary btnSmall";
        b.textContent = opt;
        b.addEventListener("click", () => {
          chunkState.picks[idx] = opt;
          renderChunkSlots();
          updateBuiltWord();
        });

        if (chunkState.picks[idx] && String(chunkState.picks[idx]).toLowerCase() === String(opt).toLowerCase()) {
          b.className = "btnSmall";
          b.style.background = "#ecfdf3";
          b.style.border = "1px solid #16a34a";
          b.style.color = "#111827";
        }
        row.appendChild(b);
      });

      chunkSlots.appendChild(slot);
    });
  }

  function updateBuiltWord() {
    builtWordPill.textContent = `ì™„ì„±: ${chunkState.picks.map(x=>x||"â–¡").join("")}`;
  }

  resetChunksBtn.addEventListener("click", () => {
    if (!chunkState) return;
    chunkState.picks.fill(null);
    chunkFeedback.textContent = "";
    renderChunkSlots();
    updateBuiltWord();
  });

  checkChunksBtn.addEventListener("click", () => {
    if (!quiz || !chunkState) return;
    const w = quiz.order[quiz.i];

    if (chunkState.picks.some(x=>!x)) { chunkFeedback.textContent = "ë¹ˆì¹¸ ìˆì–´ìš”."; return; }

    const ok = chunkState.spell.every((part,i)=>String(chunkState.picks[i]).toLowerCase()===String(part.correct).toLowerCase());
    if (ok) {
      chunkFeedback.textContent="ì •ë‹µ! âœ… (+1ì , +â­1)";
      quiz.score += 1;
      meta.stars += 1;
      meta.streak += 1;
      if (meta.streak > 0 && meta.streak % 5 === 0) meta.stars += 2;
      saveMeta();
      scorePill.textContent = `ì ìˆ˜ ${quiz.score}`;
      if (autoSpeak.checked) speakCurrentWord();
      nextBtn.style.display="inline-block";
    } else {
      chunkFeedback.textContent=`ì˜¤ë‹µ! ì •ë‹µ "${w.en}"`;
      meta.streak = 0;
      quiz.wrongIdsLocal.add(w.id);
      saveMeta();
    }
  });

  // ---------- quiz ----------
  function showQuizPanel() { quizPanel.style.display = "block"; resultPanel.style.display = "none"; }
  function showResultPanel() { quizPanel.style.display = "none"; resultPanel.style.display = "block"; }

  function startQuiz(mode, {review=false, poolOverride=null}={}) {
    const pool = poolOverride ? poolOverride : (review ? getReviewPoolFromMeta() : currentPool());
    if (words.length < 4) { alert("ì „ì²´ ë‹¨ì–´ê°€ ìµœì†Œ 4ê°œ í•„ìš”í•©ë‹ˆë‹¤."); return; }
    if (!pool || pool.length === 0) { alert("ì¶œì œí•  ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤."); return; }

    const MAX_Q = 20;
    let order = [];
    while (order.length < MAX_Q) {
      order = order.concat(shuffle([...pool]));
      if (order.length > MAX_Q) order = order.slice(0, MAX_Q);
    }

    quiz = { mode, order, i: 0, score: 0, wrongIdsLocal: new Set() };

    gameCard.style.display = "block";
    nextBtn.style.display = "none";
    feedbackEl.textContent = "";
    showQuizPanel();
    renderQuestion();
  }

  function renderQuestion() {
    if (!quiz) return;

    feedbackEl.textContent = "";
    nextBtn.style.display = "none";
    optionsEl.innerHTML = "";
    chunkArea.style.display = "none";
    chunkFeedback.textContent = "";

    const total = quiz.order.length;
    const idx = quiz.i + 1;
    idxPill.textContent = `${idx} / ${total}`;
    scorePill.textContent = `ì ìˆ˜ ${quiz.score}`;
    bar.style.width = `${Math.round((quiz.i / total) * 100)}%`;

    const w = quiz.order[quiz.i];
    currentWord = w; // ìŠ¤í”¼ì»¤ ëŒ€ìƒ

    const pool = makeChoices(w, 4);

    if (quiz.mode === "meaning") {
      stageLabel.textContent = "1ë‹¨ê³„: ëœ»";
      promptEl.textContent = w.en;
      hintEl.textContent = "ëœ» ê³ ë¥´ê¸°";
      pool.map(x => x.ko || "(ëœ» ì—†ìŒ)").forEach((label, n) => addOptionButton(label, pool[n].id === w.id, w));
      return;
    }

    if (quiz.mode === "pron") {
      stageLabel.textContent = "2ë‹¨ê³„: ë°œìŒ(í•œê¸€)";
      promptEl.textContent = w.en;
      hintEl.textContent = "ë°œìŒ ê³ ë¥´ê¸°";
      pool.map(x => x.pron || "(ë°œìŒ ì—†ìŒ)").forEach((label, n) => addOptionButton(label, pool[n].id === w.id, w));
      return;
    }

    if (quiz.mode === "spelling") {
      stageLabel.textContent = "3ë‹¨ê³„: ìŠ¤í ë§(3ì¡°ê°)";
      promptEl.textContent = w.ko || "(ëœ» ì—†ìŒ)";
      hintEl.textContent = "ì¡°ê° ì„ íƒ";
      chunkArea.style.display = "block";
      startChunkPuzzle(w);
      return;
    }
  }

  function addOptionButton(label, isCorrect, w) {
    const btn = document.createElement("button");
    btn.textContent = label;
    btn.addEventListener("click", () => onPick(btn, isCorrect, w));
    optionsEl.appendChild(btn);
  }

  function onPick(btn, isCorrect, w) {
    [...optionsEl.children].forEach(b => b.disabled = true);

    if (isCorrect) {
      btn.classList.add("correct");
      quiz.score += 1;
      meta.streak += 1;
      meta.stars += 1;
      if (meta.streak > 0 && meta.streak % 5 === 0) meta.stars += 2;
      feedbackEl.textContent = "ì •ë‹µ! ğŸ‘";
      if (autoSpeak.checked) speakCurrentWord();
    } else {
      btn.classList.add("wrong");
      feedbackEl.textContent = `ì˜¤ë‹µ! ${w.en}`;
      meta.streak = 0;
      quiz.wrongIdsLocal.add(w.id);
    }

    saveMeta();
    nextBtn.style.display = "inline-block";
  }

  function finishQuiz() {
    meta.wrongIds = Array.from(quiz.wrongIdsLocal);
    saveMeta();

    const wrongCount = meta.wrongIds.length;
    const total = quiz.order.length;
    resultTitle.textContent = "ë!";
    resultSub.textContent = `ì´ ${total}ë¬¸ì œ ì™„ë£Œ`;
    resultScorePill.textContent = `ì ìˆ˜ ${quiz.score}`;
    resultWrongPill.textContent = `ì˜¤ë‹µ ${wrongCount}`;
    resultStarsPill.textContent = `â­ ${meta.stars}`;
    resultStickersPill.textContent = `ğŸ… ${meta.stickers}`;
    retryWrongBtn.disabled = wrongCount === 0;

    showResultPanel();
  }

  nextBtn.addEventListener("click", () => {
    if (!quiz) return;
    quiz.i += 1;
    if (quiz.i >= quiz.order.length) { bar.style.width = `100%`; finishQuiz(); return; }
    renderQuestion();
  });

  skipBtn.addEventListener("click", () => {
    if (!quiz) return;
    meta.streak = 0; saveMeta();
    quiz.i += 1;
    if (quiz.i >= quiz.order.length) { bar.style.width = `100%`; finishQuiz(); return; }
    renderQuestion();
  });

  function getReviewPoolFromMeta() {
    const wrongSet = new Set(meta.wrongIds);
    return words.filter(w => wrongSet.has(w.id));
  }

  retryWrongBtn.addEventListener("click", () => {
    const pool = getReviewPoolFromMeta();
    if (pool.length === 0) return;
    startQuiz(modeSel.value, {review:true, poolOverride: pool});
  });

  retryAllBtn.addEventListener("click", () => startQuiz(modeSel.value, {review:false}));

  reviewBtn.addEventListener("click", () => {
    const pool = getReviewPoolFromMeta();
    if (pool.length === 0) { alert("í‹€ë¦° ë‹¨ì–´ ì—†ìŒ! ğŸ‘"); return; }
    startQuiz(modeSel.value, {review:true, poolOverride: pool});
  });

  // ---------- choices ----------
  function weeklyWords(){ return words.filter(w=>w.weekly); }
  function currentPool(){ return scopeSel.value==="weekly" ? weeklyWords() : words; }

  function makeChoices(correct, n) {
    const basePool = currentPool();
    const others = basePool.filter(w => w.id !== correct.id);
    const fallback = words.filter(w => w.id !== correct.id);
    const src = (others.length >= n-1) ? others : fallback;
    const picks = shuffle(src).slice(0, Math.max(0, n - 1));
    return shuffle([correct, ...picks]);
  }

  function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // ---------- admin actions ----------
  addBtn.addEventListener("click", () => {
    addWord(w_en.value, w_ko.value, w_pron.value, w_week.checked);
    w_en.value = ""; w_ko.value = ""; w_pron.value = ""; w_week.checked = false;
    w_en.focus();
  });

  bulkAddBtn.addEventListener("click", () => {
    const lines = bulk.value.split("\n").map(x => x.trim()).filter(Boolean);
    for (const line of lines) {
      const parts = (line.includes("|") ? line.split("|") : (line.includes(",") ? line.split(",") : [line]))
        .map(x => (x||"").trim());
      if (parts.length === 1) addWord(parts[0], "", "", true);
      else addWord(parts[0]||"", parts[1]||"", parts[2]||"", (parts[3]||"").toLowerCase()==="week");
    }
    bulk.value = "";
  });

  exportBtn.addEventListener("click", async () => {
    const data = JSON.stringify(words, null, 2);
    await navigator.clipboard.writeText(data).catch(()=>{});
    alert("í´ë¦½ë³´ë“œì— JSONìœ¼ë¡œ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤.");
  });

  importBtn.addEventListener("click", () => {
    const txt = prompt("ë¶™ì—¬ë„£ì„ JSONì„ ì…ë ¥í•˜ì„¸ìš” (ê¸°ì¡´ ëª©ë¡ì— ì¶”ê°€ë©ë‹ˆë‹¤).");
    if (!txt) return;
    try {
      const arr = JSON.parse(txt);
      if (!Array.isArray(arr)) throw new Error();
      for (const x of arr) addWord(x.en, x.ko, x.pron, x.weekly);
      alert("ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ");
    } catch {
      alert("JSON í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }
  });

  resetBtn.addEventListener("click", () => {
    if (!confirm("ì •ë§ ì „ì²´ ì‚­ì œí• ê¹Œìš”?")) return;
    words = [];
    meta = { stars: 0, stickers: 0, streak: 0, wrongIds: [] };
    localStorage.removeItem(LS_WORDS);
    localStorage.removeItem(LS_META);
    saveWords(); saveMeta();
  });

  clearWeeklyBtn.addEventListener("click", () => { words.forEach(w => w.weekly = false); saveWords(); });
  markAllWeeklyBtn.addEventListener("click", () => { words.forEach(w => w.weekly = true); saveWords(); });

  // ---------- start ----------
  startBtn.addEventListener("click", () => startQuiz(modeSel.value));

  seedDefaultWordsIfEmpty();
  renderCount();
  renderList();
  renderReward();

  const tts = loadTts();
  autoSpeak.checked = tts.autoSpeak;
  updateTtsNote();

  autoGameOnlyOnMobile();
})();
</script>
</body>
</html>
